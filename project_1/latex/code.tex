\documentclass{article}
\usepackage[outputdir=latex_build]{minted}
\usemintedstyle{friendly}

\begin{document}
\begin{minted}[linenos,tabsize=4]{c}
    struct node_t {
        uint16_t key;
        item_t *item;
        uint8_t level;
        node_t *children[];
    };

    struct item_t {
        uint16_t key;
        /* content of item...
         * e.g. coordinates, mass, size, etc. */
        bool is_last;
    };
\end{minted}

\begin{minted}[linenos,tabsize=4]{c}
    uint8_t insert( node_t *head, item_t items[] )
    {
        uint8_t new_levels;
        uint16_t significant_bit, level_of_common_parent;
        significant_bit = bits_at_position( items[0].key, head->level+1 );

        if ( head->children[significant_bit] != NULL ) {
            return insert( head->children[significant_bit], items );
        }
        else {
            if ( items[0].is_last )
                level_of_common_parent = 0;
            else
                level_of_common_parent = \
                    maxlevel - log( items[0].key ^ items[1].key ) / 2;

            new_levels = level_of_common_parent - head->level;
            if ( new_levels <= 0 )
                new_levels = 1;
            head->children[significant_bit] = \
                build_branch( head->level+1, new_levels, &items[0] );

            return new_levels;
        }
    }
\end{minted}

\begin{minted}[linenos,tabsize=4]{c}
    node_t *search( uint16_t key, node_t *head )
    {
        uint16_t significant_bit;
        significant_bit = bits_at_position( key, head->level+1 );
        while ( head->children != NULL
                && head->children[significant_bit] != NULL
                && key != head->key ) {
            head = head->children[significant_bit];
            significant_bit = bits_at_position( key, head->level+1 );
        }
        return head;
    }
\end{minted}

\begin{minted}[linenos,tabsize=4]{c}
    void find_neighbours( uint16_t key, node_t *head, dynarr_t *res )
    {
        int i;
        node_t *current, *tmp;
        current = search( key, head );
        uint16_t candidates[4] = {
            left( current->key ), right( current->key ),
            top( current->key ),  bot( current->key )
        };
        for ( i = 0; i < 4; ++i ) {
            if ( is_on_boundary( current->key, i ) )
                continue;
            tmp = search( candidates[i], head );
            if ( tmp->level == current->level && tmp->children != NULL )
                search_children( tmp, i, res );
            else if ( tmp->item != NULL )
                dynarr_append(res, tmp->item);
        }
    }
\end{minted}

\begin{minted}[linenos,tabsize=4]{c}
    uint16_t suffixes[4][2] = {
        { 1, 3 },   /* left */
        { 0, 2 },   /* right */
        { 2, 3 },   /* top */
        { 0, 1 }    /* bottom */
    };

    void search_children( node_t *head, int i, dynarr_t *res )
    {
        if ( head->item != NULL) {  /* i.e. head->children == NULL */
            dynarr_append( res, head->item );
        }
        else {
            if ( head->children[suffixes[i][0]] != NULL )
                search_children( head->children[suffixes[i][0]], i, res );
            if ( head->children[i][1] != NULL )
                search_children( head->children[suffixes[i][1]], i, res );
        }
    }
\end{minted}
\end{document}
